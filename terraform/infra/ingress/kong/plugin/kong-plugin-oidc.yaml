apiVersion: v1
data:
  filter.lua: |
    local M = {}

    local function shouldIgnoreRequest(patterns)
      if (patterns) then
        for _, pattern in ipairs(patterns) do
          local isMatching = not (string.find(ngx.var.uri, pattern) == nil)
          if (isMatching) then return true end
        end
      end
      return false
    end

    function M.shouldProcessRequest(config)
      return not shouldIgnoreRequest(config.filters)
    end

    return M
  handler.lua: "local OidcHandler = {\n    VERSION = \"1.3.0\",\n    PRIORITY = 1000,\n}\nlocal
    utils = require(\"kong.plugins.oidc.utils\")\nlocal filter = require(\"kong.plugins.oidc.filter\")\nlocal
    session = require(\"kong.plugins.oidc.session\")\n\n\nfunction OidcHandler:access(config)\n
    \ local oidcConfig = utils.get_options(config, ngx)\n\n  -- partial support for
    plugin chaining: allow skipping requests, where higher priority\n  -- plugin has
    already set the credentials. The 'config.anomyous' approach to define\n  -- \"and/or\"
    relationship between auth plugins is not utilized\n  if oidcConfig.skip_already_auth_requests
    and kong.client.get_credential() then\n    ngx.log(ngx.DEBUG, \"OidcHandler ignoring
    already auth request: \" .. ngx.var.request_uri)\n    return\n  end\n\n  if filter.shouldProcessRequest(oidcConfig)
    then\n    session.configure(config)\n    handle(oidcConfig)\n  else\n    ngx.log(ngx.DEBUG,
    \"OidcHandler ignoring request, path: \" .. ngx.var.request_uri)\n  end\n\n  ngx.log(ngx.DEBUG,
    \"OidcHandler done\")\nend\n\nfunction handle(oidcConfig)\n  local response\n\n
    \ if oidcConfig.bearer_jwt_auth_enable then\n    response = verify_bearer_jwt(oidcConfig)\n
    \   if response then\n      utils.setCredentials(response)\n      utils.injectGroups(response,
    oidcConfig.groups_claim)\n      utils.injectHeaders(oidcConfig.header_names, oidcConfig.header_claims,
    { response })\n      if not oidcConfig.disable_userinfo_header then\n        utils.injectUser(response,
    oidcConfig.userinfo_header_name)\n      end\n      return\n    end\n  end\n\n
    \ if oidcConfig.introspection_endpoint then\n    response = introspect(oidcConfig)\n
    \   if response then\n      utils.setCredentials(response)\n      utils.injectGroups(response,
    oidcConfig.groups_claim)\n      utils.injectHeaders(oidcConfig.header_names, oidcConfig.header_claims,
    { response })\n      if not oidcConfig.disable_userinfo_header then\n        utils.injectUser(response,
    oidcConfig.userinfo_header_name)\n      end\n    end\n  end\n\n  if response ==
    nil then\n    response = make_oidc(oidcConfig)\n    if response then\n      if
    response.user or response.id_token then\n        -- is there any scenario where
    lua-resty-openidc would not provide id_token?\n        utils.setCredentials(response.user
    or response.id_token)\n      end\n      if response.user and response.user[oidcConfig.groups_claim]
    \ ~= nil then\n        utils.injectGroups(response.user, oidcConfig.groups_claim)\n
    \     elseif response.id_token then\n        utils.injectGroups(response.id_token,
    oidcConfig.groups_claim)\n      end\n      utils.injectHeaders(oidcConfig.header_names,
    oidcConfig.header_claims, { response.user, response.id_token })\n      if (not
    oidcConfig.disable_userinfo_header\n          and response.user) then\n        utils.injectUser(response.user,
    oidcConfig.userinfo_header_name)\n      end\n      if (not oidcConfig.disable_access_token_header\n
    \         and response.access_token) then\n        utils.injectAccessToken(response.access_token,
    oidcConfig.access_token_header_name, oidcConfig.access_token_as_bearer)\n      end\n
    \     if (not oidcConfig.disable_id_token_header\n          and response.id_token)
    then\n        utils.injectIDToken(response.id_token, oidcConfig.id_token_header_name)\n
    \     end\n    end\n  end\nend\n\nfunction make_oidc(oidcConfig)\n  ngx.log(ngx.DEBUG,
    \"OidcHandler calling authenticate, requested path: \" .. ngx.var.request_uri)\n
    \ local unauth_action = oidcConfig.unauth_action\n  if unauth_action ~= \"auth\"
    then\n    -- constant for resty.oidc library\n    unauth_action = \"deny\"\n  end\n
    \ local res, err = require(\"resty.openidc\").authenticate(oidcConfig, ngx.var.request_uri,
    unauth_action)\n\n  if err then\n    if err == 'unauthorized request' then\n      return
    kong.response.error(ngx.HTTP_UNAUTHORIZED)\n    else\n      if oidcConfig.recovery_page_path
    then\n    \t  ngx.log(ngx.DEBUG, \"Redirecting to recovery page: \" .. oidcConfig.recovery_page_path)\n
    \       ngx.redirect(oidcConfig.recovery_page_path)\n      end\n      return kong.response.error(ngx.HTTP_INTERNAL_SERVER_ERROR)\n
    \   end\n  end\n  return res\nend\n\nfunction introspect(oidcConfig)\n  if utils.has_bearer_access_token()
    or oidcConfig.bearer_only == \"yes\" then\n    local res, err\n    if oidcConfig.use_jwks
    == \"yes\" then\n      res, err = require(\"resty.openidc\").bearer_jwt_verify(oidcConfig)\n
    \   else\n      res, err = require(\"resty.openidc\").introspect(oidcConfig)\n
    \   end\n    if err then\n      if oidcConfig.bearer_only == \"yes\" then\n        ngx.header[\"WWW-Authenticate\"]
    = 'Bearer realm=\"' .. oidcConfig.realm .. '\",error=\"' .. err .. '\"'\n        return
    kong.response.error(ngx.HTTP_UNAUTHORIZED)\n      end\n      return nil\n    end\n
    \   if oidcConfig.validate_scope == \"yes\" then\n      local validScope = false\n
    \     if res.scope then\n        for scope in res.scope:gmatch(\"([^ ]+)\") do\n
    \         if scope == oidcConfig.scope then\n            validScope = true\n            break\n
    \         end\n        end\n      end\n      if not validScope then\n        kong.log.err(\"Scope
    validation failed\")\n        return kong.response.error(ngx.HTTP_FORBIDDEN)\n
    \     end\n    end\n    ngx.log(ngx.DEBUG, \"OidcHandler introspect succeeded,
    requested path: \" .. ngx.var.request_uri)\n    return res\n  end\n  return nil\nend\n\nfunction
    verify_bearer_jwt(oidcConfig)\n  if not utils.has_bearer_access_token() then\n
    \   return nil\n  end\n  -- setup controlled configuration for bearer_jwt_verify\n
    \ local opts = {\n    accept_none_alg = false,\n    accept_unsupported_alg = false,\n
    \   token_signing_alg_values_expected = oidcConfig.bearer_jwt_auth_signing_algs,\n
    \   discovery = oidcConfig.discovery,\n    timeout = oidcConfig.timeout,\n    ssl_verify
    = oidcConfig.ssl_verify\n  }\n\n  local discovery_doc, err = require(\"resty.openidc\").get_discovery_doc(opts)\n
    \ if err then\n    kong.log.err('Discovery document retrieval for Bearer JWT verify
    failed')\n    return nil\n  end\n\n  local allowed_auds = oidcConfig.bearer_jwt_auth_allowed_auds
    or oidcConfig.client_id\n\n  local jwt_validators = require \"resty.jwt-validators\"\n
    \ jwt_validators.set_system_leeway(120)\n  local claim_spec = {\n    -- mandatory
    for id token: iss, sub, aud, exp, iat\n    iss = jwt_validators.equals(discovery_doc.issuer),\n
    \   sub = jwt_validators.required(),\n    aud = function(val) return utils.has_common_item(val,
    allowed_auds) end,\n    exp = jwt_validators.is_not_expired(),\n    iat = jwt_validators.required(),\n
    \   -- optional validations\n    nbf = jwt_validators.opt_is_not_before(),\n  }\n\n
    \ local json, err, token = require(\"resty.openidc\").bearer_jwt_verify(opts,
    claim_spec)\n  if err then\n    kong.log.err('Bearer JWT verify failed: ' .. err)\n
    \   return nil\n  end\n\n  return json\nend\n\nreturn OidcHandler\n"
  schema.lua: |
    local typedefs = require "kong.db.schema.typedefs"

    return {
      name = "kong-oidc",
      fields = {
        {
          -- this plugin will only be applied to Services or Routes
          consumer = typedefs.no_consumer
        },
        {
          -- this plugin will only run within Nginx HTTP module
          protocols = typedefs.protocols_http
        },
        {
          config = {
            type = "record",
            fields = {
              {
                client_id = {
                  type = "string",
                  required = true
                }
              },
              {
                client_secret = {
                  type = "string",
                  required = true
                }
              },
              {
                discovery = {
                  type = "string",
                  required = true,
                  default = "https://.well-known/openid-configuration"
                }
              },
              {
                introspection_endpoint = {
                  type = "string",
                  required = false
                }
              },
              {
                introspection_endpoint_auth_method = {
                  type = "string",
                  required = false
                }
              },
              {
                introspection_cache_ignore = {
                  type = "string",
                  required = true,
                  default = "no"
                }
              },
              {
                timeout = {
                  type = "number",
                  required = false
                }
              },
              {
                bearer_only = {
                  type = "string",
                  required = true,
                  default = "no"
                }
              },
              {
                realm = {
                  type = "string",
                  required = true,
                  default = "kong"
                }
              },
              {
                redirect_uri = {
                  type = "string"
                }
              },
              {
                scope = {
                  type = "string",
                  required = true,
                  default = "openid"
                }
              },
              {
                validate_scope = {
                  type = "string",
                  required = true,
                  default = "no"
                }
              },
              {
                response_type = {
                  type = "string",
                  required = true,
                  default = "code"
                }
              },
              {
                ssl_verify = {
                  type = "string",
                  required = true,
                  default = "no"
                }
              },
              {
                use_jwks = {
                  type = "string",
                  required = true,
                  default = "no"
                }
              },
              {
                token_endpoint_auth_method = {
                  type = "string",
                  required = true,
                  default = "client_secret_post"
                }
              },
              {
                session_secret = {
                  type = "string",
                  required = false
                }
              },
              {
                recovery_page_path = {
                  type = "string"
                }
              },
              {
                logout_path = {
                  type = "string",
                  required = false,
                  default = "/logout"
                }
              },
              {
                redirect_after_logout_uri = {
                  type = "string",
                  required = false,
                  default = "/"
                }
              },
              {
                redirect_after_logout_with_id_token_hint = {
                  type = "string",
                  required = false,
                  default = "no"
                }
              },
              {
                post_logout_redirect_uri = {
                  type = "string",
                  required = false
                }
              },
              {
                unauth_action = {
                  type = "string",
                  required = false,
                  default = "auth"
                }
              },
              {
                filters = {
                  type = "string"
                }
              },
              {
                ignore_auth_filters = {
                  type = "string",
                  required = false
                }
              },
              {
                userinfo_header_name = {
                  type = "string",
                  required = false,
                  default = "X-USERINFO"
                }
              },
              {
                id_token_header_name = {
                  type = "string",
                  required = false,
                  default = "X-ID-Token"
                }
              },
              {
                access_token_header_name = {
                  type = "string",
                  required = false,
                  default = "X-Access-Token"
                }
              },
              {
                access_token_as_bearer = {
                  type = "string",
                  required = false,
                  default = "no"
                }
              },
              {
                disable_userinfo_header = {
                  type = "string",
                  required = false,
                  default = "no"
                }
              },
              {
                disable_id_token_header = {
                  type = "string",
                  required = false,
                  default = "no"
                }
              },
              {
                disable_access_token_header = {
                  type = "string",
                  required = false,
                  default = "no"
                }
              },
              {
                revoke_tokens_on_logout = {
                  type = "string",
                  required = false,
                  default = "no"
                }
              },
              {
                groups_claim = {
                  type = "string",
                  required = false,
                  default = "groups"
                }
              },
              {
                skip_already_auth_requests = {
                  type = "string",
                  required = false,
                  default = "no"
                }
              },
              {
                bearer_jwt_auth_enable = {
                  type = "string",
                  required = false,
                  default = "no"
                }
              },
              {
                bearer_jwt_auth_allowed_auds = {
                  type = "array",
                  required = false,
                  elements = {
                    type = "string"
                  },
                }
              },
              {
                bearer_jwt_auth_signing_algs = {
                  type = "array",
                  required = true,
                  elements = {
                    type = "string"
                  },
                  default = {
                    "RS256"
                  }
                }
              },
              {
                header_names = {
                  type = "array",
                  required = true,
                  elements = {
                    type = "string"
                  },
                  default = {}
                }
              },
              {
                header_claims = {
                  type = "array",
                  required = true,
                  elements = {
                    type = "string"
                  },
                  default = {}
                }
              },
              {
                http_proxy = {
                  type = "string",
                  required = false
                }
              },
              {
                https_proxy = {
                  type = "string",
                  required = false
                }
              }
            }
          }
        }
      }
    }
  session.lua: |
    local M = {}

    function M.configure(config)
      if config.session_secret then
        local decoded_session_secret = ngx.decode_base64(config.session_secret)
        if not decoded_session_secret then
          kong.log.err("Invalid plugin configuration, session secret could not be decoded")
          return kong.response.error(ngx.HTTP_INTERNAL_SERVER_ERROR)
        end
        ngx.var.session_secret = decoded_session_secret
      end
    end

    return M
  utils.lua: "local cjson = require(\"cjson\")\nlocal constants = require \"kong.constants\"\n\nlocal
    M = {}\n\nlocal function parseFilters(csvFilters)\n  local filters = {}\n  if
    (not (csvFilters == nil)) and (not (csvFilters == \",\")) then\n    for pattern
    in string.gmatch(csvFilters, \"[^,]+\") do\n      table.insert(filters, pattern)\n
    \   end\n  end\n  return filters\nend\n\nlocal function formatAsBearerToken(token)\n
    \ return \"Bearer \" .. token\nend\n\nfunction M.get_redirect_uri(ngx)\n  local
    function drop_query()\n    local uri = ngx.var.request_uri\n    local x = uri:find(\"?\")\n
    \   if x then\n      return uri:sub(1, x - 1)\n    else\n      return uri\n    end\n
    \ end\n\n  local function tackle_slash(path)\n    local args = ngx.req.get_uri_args()\n
    \   if args and args.code then\n      return path\n    elseif path == \"/\" then\n
    \     return \"/cb\"\n    elseif path:sub(-1) == \"/\" then\n      return path:sub(1,
    -2)\n    else\n      return path .. \"/\"\n    end\n  end\n\n  return tackle_slash(drop_query())\nend\n\nfunction
    M.get_options(config, ngx)\n  return {\n    client_id = config.client_id,\n    client_secret
    = config.client_secret,\n    discovery = config.discovery,\n    introspection_endpoint
    = config.introspection_endpoint,\n    introspection_endpoint_auth_method = config.introspection_endpoint_auth_method,\n
    \   introspection_cache_ignore = config.introspection_cache_ignore,\n    timeout
    = config.timeout,\n    bearer_only = config.bearer_only,\n    realm = config.realm,\n
    \   redirect_uri = config.redirect_uri or M.get_redirect_uri(ngx),\n    scope
    = config.scope,\n    validate_scope = config.validate_scope,\n    response_type
    = config.response_type,\n    ssl_verify = config.ssl_verify,\n    use_jwks = config.use_jwks,\n
    \   token_endpoint_auth_method = config.token_endpoint_auth_method,\n    recovery_page_path
    = config.recovery_page_path,\n    filters = parseFilters((config.filters or \"\")
    .. \",\" .. (config.ignore_auth_filters or \"\")),\n    logout_path = config.logout_path,\n
    \   revoke_tokens_on_logout = config.revoke_tokens_on_logout == \"yes\",\n    redirect_after_logout_uri
    = config.redirect_after_logout_uri,\n    redirect_after_logout_with_id_token_hint
    = config.redirect_after_logout_with_id_token_hint == \"yes\",\n    post_logout_redirect_uri
    = config.post_logout_redirect_uri,\n    unauth_action = config.unauth_action,\n
    \   userinfo_header_name = config.userinfo_header_name,\n    id_token_header_name
    = config.id_token_header_name,\n    access_token_header_name = config.access_token_header_name,\n
    \   access_token_as_bearer = config.access_token_as_bearer == \"yes\",\n    disable_userinfo_header
    = config.disable_userinfo_header == \"yes\",\n    disable_id_token_header = config.disable_id_token_header
    == \"yes\",\n    disable_access_token_header = config.disable_access_token_header
    == \"yes\",\n    groups_claim = config.groups_claim,\n    skip_already_auth_requests
    = config.skip_already_auth_requests == \"yes\",\n    bearer_jwt_auth_enable =
    config.bearer_jwt_auth_enable == \"yes\",\n    bearer_jwt_auth_allowed_auds =
    config.bearer_jwt_auth_allowed_auds,\n    bearer_jwt_auth_signing_algs = config.bearer_jwt_auth_signing_algs,\n
    \   header_names = config.header_names or {},\n    header_claims = config.header_claims
    or {},\n    proxy_opts = {\n      http_proxy  = config.http_proxy,\n      https_proxy
    = config.https_proxy\n    }\n  }\nend\n\n-- Function set_consumer is derived from
    the following kong auth plugins:\n-- https://github.com/Kong/kong/blob/3.0.0/kong/plugins/ldap-auth/access.lua\n--
    https://github.com/Kong/kong/blob/3.0.0/kong/plugins/oauth2/access.lua\n-- Copyright
    2016-2022 Kong Inc. Licensed under the Apache License, Version 2.0\n-- https://github.com/Kong/kong/blob/3.0.0/LICENSE\nlocal
    function set_consumer(consumer, credential)\n  kong.client.authenticate(consumer,
    credential)\n\n  local set_header = kong.service.request.set_header\n  local clear_header
    = kong.service.request.clear_header\n\n  if consumer and consumer.id then\n    set_header(constants.HEADERS.CONSUMER_ID,
    consumer.id)\n  else\n    clear_header(constants.HEADERS.CONSUMER_ID)\n  end\n\n
    \ if consumer and consumer.custom_id then\n    set_header(constants.HEADERS.CONSUMER_CUSTOM_ID,
    consumer.custom_id)\n  else\n    clear_header(constants.HEADERS.CONSUMER_CUSTOM_ID)\n
    \ end\n\n  if consumer and consumer.username then\n    set_header(constants.HEADERS.CONSUMER_USERNAME,
    consumer.username)\n  else\n    clear_header(constants.HEADERS.CONSUMER_USERNAME)\n
    \ end\n\n  if credential and credential.username then\n    set_header(constants.HEADERS.CREDENTIAL_IDENTIFIER,
    credential.username)\n  else\n    clear_header(constants.HEADERS.CREDENTIAL_IDENTIFIER)\n
    \ end\n\n  if credential then\n    clear_header(constants.HEADERS.ANONYMOUS)\n
    \ else\n    set_header(constants.HEADERS.ANONYMOUS, true)\n  end\nend\n\nfunction
    M.injectAccessToken(accessToken, headerName, bearerToken)\n  ngx.log(ngx.DEBUG,
    \"Injecting \" .. headerName)\n  local token = accessToken\n  if (bearerToken)
    then\n    token = formatAsBearerToken(token)\n  end\n  kong.service.request.set_header(headerName,
    token)\nend\n\nfunction M.injectIDToken(idToken, headerName)\n  ngx.log(ngx.DEBUG,
    \"Injecting \" .. headerName)\n  local tokenStr = cjson.encode(idToken)\n  kong.service.request.set_header(headerName,
    ngx.encode_base64(tokenStr))\nend\n\nfunction M.setCredentials(user)\n  local
    tmp_user = user\n  tmp_user.id = user.sub\n  tmp_user.username = user.preferred_username\n
    \ set_consumer(nil, tmp_user)\nend\n\nfunction M.injectUser(user, headerName)\n
    \ ngx.log(ngx.DEBUG, \"Injecting \" .. headerName)\n  local userinfo = cjson.encode(user)\n
    \ kong.service.request.set_header(headerName, ngx.encode_base64(userinfo))\nend\n\nfunction
    M.injectGroups(user, claim)\n  if user[claim] ~= nil then\n    kong.ctx.shared.authenticated_groups
    = user[claim]\n  end\nend\n\nfunction M.injectHeaders(header_names, header_claims,
    sources)\n  if #header_names ~= #header_claims then\n    kong.log.err('Different
    number of elements provided in header_names and header_claims. Headers will not
    be added.')\n    return\n  end\n  for i = 1, #header_names do\n    local header,
    claim\n    header = header_names[i]\n    claim = header_claims[i] \n    kong.service.request.clear_header(header)\n
    \   for j = 1, #sources do\n      local source, claim_value\n      source = sources[j]\n
    \     claim_value = source[claim]\n      -- Convert table to string if claim is
    a table\n      if type(claim_value) == \"table\" then\n        claim_value = table.concat(claim_value,
    \", \")\n      end\n      if (source and source[claim]) then\n        kong.service.request.set_header(header,
    claim_value)\n        break\n      end\n    end\n  end\nend\n\nfunction M.has_bearer_access_token()\n
    \ local header = ngx.req.get_headers()['Authorization']\n  if header and header:find(\"
    \") then\n    local divider = header:find(' ')\n    if string.lower(header:sub(0,
    divider-1)) == string.lower(\"Bearer\") then\n      return true\n    end\n  end\n
    \ return false\nend\n\n-- verify if tables t1 and t2 have at least one common
    string item\n-- instead of table, also string can be provided as t1 or t2\nfunction
    M.has_common_item(t1, t2)\n  if t1 == nil or t2 == nil then\n    return false\n
    \ end\n  if type(t1) == \"string\" then\n    t1 = { t1 }\n  end\n  if type(t2)
    == \"string\" then\n    t2 = { t2 }\n  end\n  local i1, i2\n  for _, i1 in pairs(t1)
    do\n    for _, i2 in pairs(t2) do\n      if type(i1) == \"string\" and type(i2)
    == \"string\" and i1 == i2 then\n        return true\n      end\n    end\n  end\n
    \ return false\nend\n\nreturn M\n"
kind: ConfigMap
metadata:
  creationTimestamp: null
  name: kong-plugin-oidc
